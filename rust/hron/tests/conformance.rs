//! Conformance test runner â€” drives all tests from spec/tests.json.
//!
//! Individual `#[test]` functions are generated by build.rs from the spec,
//! so each case appears separately in `cargo test` output.

use hron::Schedule;
use serde_json::Value;
use std::sync::LazyLock;

static SPEC: LazyLock<Value> = LazyLock::new(|| {
    serde_json::from_str(include_str!("../../../spec/tests.json"))
        .expect("spec/tests.json is invalid JSON")
});

fn default_now() -> jiff::Zoned {
    SPEC["now"]
        .as_str()
        .expect("top-level 'now' missing")
        .parse()
        .expect("invalid 'now' timestamp")
}

fn parse_zoned(s: &str) -> jiff::Zoned {
    s.parse()
        .unwrap_or_else(|e| panic!("bad timestamp '{s}': {e}"))
}

// ---------------------------------------------------------------------------
// Parse
// ---------------------------------------------------------------------------

fn run_parse_roundtrip(section: &str, index: usize) {
    let case = &SPEC["parse"][section]["tests"][index];
    let input = case["input"].as_str().unwrap();
    let canonical = case["canonical"].as_str().unwrap();

    let schedule =
        Schedule::parse(input).unwrap_or_else(|e| panic!("parse failed for '{input}': {e}"));
    let display = schedule.to_string();
    assert_eq!(display, canonical, "display mismatch for '{input}'");

    // Idempotent: parse(canonical).to_string() == canonical
    let s2 = Schedule::parse(canonical)
        .unwrap_or_else(|e| panic!("re-parse canonical failed for '{canonical}': {e}"));
    assert_eq!(
        s2.to_string(),
        canonical,
        "canonical not idempotent for '{canonical}'"
    );
}

fn run_parse_error(index: usize) {
    let case = &SPEC["parse_errors"]["tests"][index];
    let input = case["input"].as_str().unwrap();

    if let Ok(s) = Schedule::parse(input) {
        panic!("expected parse error for '{input}', got: {s}");
    }
}

// ---------------------------------------------------------------------------
// Eval
// ---------------------------------------------------------------------------

fn run_eval(section: &str, index: usize) {
    let case = &SPEC["eval"][section]["tests"][index];
    let expr_str = case["expression"].as_str().unwrap();

    let schedule =
        Schedule::parse(expr_str).unwrap_or_else(|e| panic!("parse failed for '{expr_str}': {e}"));

    let now = case["now"]
        .as_str()
        .map(|s| parse_zoned(s))
        .unwrap_or_else(|| default_now());

    // ---- next (full timestamp) ----
    if let Some(expected_val) = case.get("next") {
        let result = schedule
            .next_from(&now)
            .unwrap_or_else(|e| panic!("next_from error for '{expr_str}': {e}"));
        if expected_val.is_null() {
            assert!(
                result.is_none(),
                "expected null for '{expr_str}', got {:?}",
                result.map(|z| z.to_string())
            );
        } else {
            let expected = expected_val.as_str().unwrap();
            let got = result.unwrap_or_else(|| panic!("next: got None, expected '{expected}'"));
            assert_eq!(got.to_string(), expected, "next mismatch for '{expr_str}'");
        }
    }

    // ---- next_date (date-only check) ----
    if let Some(expected_date) = case.get("next_date") {
        let expected = expected_date.as_str().unwrap();
        let got = schedule
            .next_from(&now)
            .unwrap_or_else(|e| panic!("next_from error for '{expr_str}': {e}"))
            .unwrap_or_else(|| panic!("next_date: got None, expected '{expected}'"));
        assert_eq!(
            got.date().to_string(),
            expected,
            "next_date mismatch for '{expr_str}'"
        );
    }

    // ---- next_n (list of timestamps) ----
    if let Some(expected_arr) = case.get("next_n") {
        let expected: Vec<&str> = expected_arr
            .as_array()
            .unwrap()
            .iter()
            .map(|v| v.as_str().unwrap())
            .collect();

        let n_count = case
            .get("next_n_count")
            .and_then(|v| v.as_u64())
            .unwrap_or(expected.len() as u64) as usize;

        let results = schedule
            .next_n_from(&now, n_count)
            .unwrap_or_else(|e| panic!("next_n_from error for '{expr_str}': {e}"));
        let got: Vec<String> = results.iter().map(|z| z.to_string()).collect();

        assert_eq!(
            got.len(),
            expected.len(),
            "next_n length mismatch for '{expr_str}': got {got:?}"
        );
        for (j, (g, e)) in got.iter().zip(expected.iter()).enumerate() {
            assert_eq!(g, e, "next_n[{j}] mismatch for '{expr_str}'");
        }
    }

    // ---- next_n_length (just check count) ----
    if let Some(expected_len) = case.get("next_n_length") {
        let expected = expected_len.as_u64().unwrap() as usize;
        let n_count = case["next_n_count"].as_u64().unwrap() as usize;
        let results = schedule
            .next_n_from(&now, n_count)
            .unwrap_or_else(|e| panic!("next_n_from error for '{expr_str}': {e}"));
        assert_eq!(
            results.len(),
            expected,
            "next_n_length mismatch for '{expr_str}'"
        );
    }
}

fn run_eval_matches(index: usize) {
    let case = &SPEC["eval"]["matches"]["tests"][index];
    let expr_str = case["expression"].as_str().unwrap();
    let dt_str = case["datetime"].as_str().unwrap();
    let expected = case["expected"].as_bool().unwrap();

    let schedule =
        Schedule::parse(expr_str).unwrap_or_else(|e| panic!("parse failed for '{expr_str}': {e}"));
    let dt = parse_zoned(dt_str);
    let got = schedule
        .matches(&dt)
        .unwrap_or_else(|e| panic!("matches error for '{expr_str}': {e}"));

    assert_eq!(
        got, expected,
        "matches mismatch for '{expr_str}' at {dt_str}"
    );
}

fn run_eval_occurrences(index: usize) {
    let case = &SPEC["eval"]["occurrences"]["tests"][index];
    let expr_str = case["expression"].as_str().unwrap();
    let from_str = case["from"].as_str().unwrap();
    let take = case["take"].as_u64().unwrap() as usize;
    let expected: Vec<&str> = case["expected"]
        .as_array()
        .unwrap()
        .iter()
        .map(|v| v.as_str().unwrap())
        .collect();

    let schedule =
        Schedule::parse(expr_str).unwrap_or_else(|e| panic!("parse failed for '{expr_str}': {e}"));
    let from = parse_zoned(from_str);

    let results: Vec<jiff::Zoned> = schedule
        .occurrences(&from)
        .take(take)
        .collect::<Result<Vec<_>, _>>()
        .unwrap_or_else(|e| panic!("occurrences error for '{expr_str}': {e}"));

    let got: Vec<String> = results.iter().map(|z| z.to_string()).collect();

    assert_eq!(
        got.len(),
        expected.len(),
        "occurrences length mismatch for '{expr_str}': got {got:?}"
    );
    for (j, (g, e)) in got.iter().zip(expected.iter()).enumerate() {
        assert_eq!(g, e, "occurrences[{j}] mismatch for '{expr_str}'");
    }
}

fn run_eval_between(index: usize) {
    let case = &SPEC["eval"]["between"]["tests"][index];
    let expr_str = case["expression"].as_str().unwrap();
    let from_str = case["from"].as_str().unwrap();
    let to_str = case["to"].as_str().unwrap();

    let schedule =
        Schedule::parse(expr_str).unwrap_or_else(|e| panic!("parse failed for '{expr_str}': {e}"));
    let from = parse_zoned(from_str);
    let to = parse_zoned(to_str);

    let results: Vec<jiff::Zoned> = schedule
        .between(&from, &to)
        .collect::<Result<Vec<_>, _>>()
        .unwrap_or_else(|e| panic!("between error for '{expr_str}': {e}"));

    // Check expected array or expected_count
    if let Some(expected_arr) = case.get("expected") {
        let expected: Vec<&str> = expected_arr
            .as_array()
            .unwrap()
            .iter()
            .map(|v| v.as_str().unwrap())
            .collect();

        let got: Vec<String> = results.iter().map(|z| z.to_string()).collect();

        assert_eq!(
            got.len(),
            expected.len(),
            "between length mismatch for '{expr_str}': got {got:?}"
        );
        for (j, (g, e)) in got.iter().zip(expected.iter()).enumerate() {
            assert_eq!(g, e, "between[{j}] mismatch for '{expr_str}'");
        }
    } else if let Some(expected_count) = case.get("expected_count") {
        let count = expected_count.as_u64().unwrap() as usize;
        assert_eq!(
            results.len(),
            count,
            "between count mismatch for '{expr_str}'"
        );
    }
}

// ---------------------------------------------------------------------------
// Cron
// ---------------------------------------------------------------------------

fn run_cron_to_cron(index: usize) {
    let case = &SPEC["cron"]["to_cron"]["tests"][index];
    let hron_expr = case["hron"].as_str().unwrap();
    let expected_cron = case["cron"].as_str().unwrap();

    let schedule = Schedule::parse(hron_expr)
        .unwrap_or_else(|e| panic!("parse failed for '{hron_expr}': {e}"));
    let got = schedule
        .to_cron()
        .unwrap_or_else(|e| panic!("to_cron failed for '{hron_expr}': {e}"));
    assert_eq!(got, expected_cron, "to_cron mismatch for '{hron_expr}'");
}

fn run_cron_to_cron_error(index: usize) {
    let case = &SPEC["cron"]["to_cron_errors"]["tests"][index];
    let hron_expr = case["hron"].as_str().unwrap();

    let schedule = Schedule::parse(hron_expr)
        .unwrap_or_else(|e| panic!("parse failed for '{hron_expr}': {e}"));
    if let Ok(got) = schedule.to_cron() {
        panic!("expected to_cron error for '{hron_expr}', got '{got}'");
    }
}

fn run_cron_from_cron(index: usize) {
    let case = &SPEC["cron"]["from_cron"]["tests"][index];
    let cron_expr = case["cron"].as_str().unwrap();
    let expected_hron = case["hron"].as_str().unwrap();

    let schedule = Schedule::from_cron(cron_expr)
        .unwrap_or_else(|e| panic!("from_cron failed for '{cron_expr}': {e}"));
    let got = schedule.to_string();
    assert_eq!(got, expected_hron, "from_cron mismatch for '{cron_expr}'");
}

fn run_cron_from_cron_error(index: usize) {
    let case = &SPEC["cron"]["from_cron_errors"]["tests"][index];
    let cron_expr = case["cron"].as_str().unwrap();

    if let Ok(s) = Schedule::from_cron(cron_expr) {
        panic!("expected from_cron error for '{cron_expr}', got: {s}");
    }
}

fn run_cron_roundtrip(index: usize) {
    let case = &SPEC["cron"]["roundtrip"]["tests"][index];
    let hron_expr = case["hron"].as_str().unwrap();

    let schedule = Schedule::parse(hron_expr)
        .unwrap_or_else(|e| panic!("parse failed for '{hron_expr}': {e}"));
    let cron1 = schedule
        .to_cron()
        .unwrap_or_else(|e| panic!("to_cron failed for '{hron_expr}': {e}"));
    let back = Schedule::from_cron(&cron1)
        .unwrap_or_else(|e| panic!("from_cron failed for '{cron1}': {e}"));
    let cron2 = back
        .to_cron()
        .unwrap_or_else(|e| panic!("re-to_cron failed for '{hron_expr}': {e}"));
    assert_eq!(cron1, cron2, "roundtrip mismatch for '{hron_expr}'");
}

// ---------------------------------------------------------------------------
// Generated test functions (one per spec case)
// ---------------------------------------------------------------------------

include!(concat!(env!("OUT_DIR"), "/conformance_tests.rs"));
